import os, sys, requests, numpy
from bs4 import BeautifulSoup

staticespn = (
    r"http://www.espn.com/college-football/rankings/_/week/6/year/2018/seasontype/2"
)
currentespnap = r"http://www.espn.com/college-football/rankings"
# defaultlink = currentespnap
oldurl1 = r"http://www.espn.com/college-football/rankings/_/week/"
# Should be the default URL:
aponlylinkespn2 = r"http://www.espn.com/college-football/rankings/_/poll/1/week/"
defaultlink = aponlylinkespn2

tfcounter = 0
tfive = []
while tfcounter < 25:
    tfcounter += 1
    tfive.append(tfcounter)


def findnth(haystack, needle, n):
    """ <https://stackoverflow.com/questions/1883980/find-the-nth-occurrence-of-substring-in-a-string> """
    n = n - 1
    parts = haystack.split(needle, n + 1)
    if len(parts) <= n + 1:
        return -1
    return len(haystack) - len(parts[-1]) - len(needle)


def apweeklyurlgenerator(week, year):
    """ Generate a URL link for a specific week of AP Rankings. Preseason = week 1 """
    finallist = ["final", "f", "complete", "total", "last"]
    prelist = ["preseason", "initial", "first", "init", "pre", str(0)]
    currentlist = ["current", "present", "default"]

    # Format the year correctly
    year = str(year)
    if len(year) != 4:
        if len(year) == 2 and (year[0] == "1" or year[0] == "0"):
            # Assume the entry was an abreviation of a year. Add the 20__ before it.
            year = "20" + str(year)

    # Preseason?
    week = str(week)
    if week.lower() in prelist:
        week = "1"
    # If the week entered is higher than 16, assume user wants final rankings.
    try:
        if int(week) > 16:
            week = "final"
    except:
        pass

    # Generate the URL
    # Default link here (see the top of script for variable definition)
    url1 = defaultlink
    # Is the week entered indicating the final week?
    if week.lower() in finallist:
        oldfinalurlexample = "http://www.espn.com/college-football/rankings/_/week/1/year/2017/seasontype/3"
        week1 = "1/year/"
        seasontype = "/seasontype/3"
        url = url1 + week1 + year + seasontype
    # Check for entries wanting the most up-to-date rankings
    elif week.lower() in currentlist:
        # just use the default link
        url = url1  # default link
    # # Commented out b/c we want the user to get the results they want and not be confused by getting the current week
    # #     when they wanted another week. This will error out to let them know that.
    # elif week is None:
    #     # just use the default link by passing
    #     pass
    else:
        url2 = r"/year/"
        url3 = r"/seasontype/2"
        url = url1 + str(week) + url2 + year + url3
    print "Week", week, ",", year, "season"
    return url
    # Should be the default URL: r"http://www.espn.com/college-football/rankings/_/poll/1/"


def pollgrabber(aplink):
    """ Use BeautifulSoup to grab the AP Poll from ESPN's website,
    the link to which is generated by apweeklyurlgenerator() """
    print aplink
    r = requests.get(aplink)
    soup = BeautifulSoup(r.content, "html.parser")  # , 'html5lib')
    # trsearch = soup.find_all('title')
    trsearch = soup.find_all("div")  # 'table-caption')
    # print trsearch
    print "- - - - - - - -"
    nodecounter = 0
    ##########
    strsearch = str(trsearch)
    # print strsearch
    return strsearch


def gettoptfive(websitestrsearch):
    """ Parses the string-searched soup from bs4's html output of the AP Poll from ESPN generated by pollgrabber() """
    toptfive = {}
    nodecounter = 0
    inverserankings = {}

    strsearch = websitestrsearch
    # # Print this only to see the long version of the html returned by the search. Too much for PyCharm run window rn.
    # print strsearch

    apsearchterm = "AP Top 25"  # 'class="number">1'
    for ranking in tfive:
        # print "Ranking in Top 25:", ranking  ## Test print statement delete
        # Commented out search strs no longer used but kept in case of future troubleshooting.
        # searchno1 = 'class="number">' + str(ranking) + '<'
        #  searchno1 = '<td class="tight-cell Table2__td">' + str(ranking) + "<"
        # # 2019 edit
        # searchno1 = '<td class="Table2__td">' + str(ranking) + "<"
        # # 2019 edit 2
        searchno1 = '<td class="Table__TD">' + str(ranking) + "<"

        # searchno2 = 'class="number">' + str(ranking + 1) + '<'
        #  searchno2 = '<td class="tight-cell Table2__td">' + str(ranking+1) + "<"
        # # 2019 edit
        # searchno2 = '<td class="Table2__td">' + str(ranking + 1) + "<"
        # # 2019 edit
        searchno2 = '<td class="Table__TD">' + str(ranking + 1) + "<"

        # teamsearchstart = '<span class="team-names">'
        teamsearchstart = 'px" title="'
        # teamsearchend = '</span><abbr title='
        teamsearchend = '"/></a></span>'

        tieteamlist = []
        if (
            apsearchterm.lower() in strsearch.lower()
            and searchno1.lower() in strsearch.lower()
        ):
            findap = strsearch.find(apsearchterm)
            findno1 = strsearch.lower().find(searchno1.lower())
            findno2 = strsearch.lower().find(searchno2.lower())
            outstring = strsearch[
                findno1:findno2
            ]  # +len(searchno2)]#]#Restore to the only ]
            # print ranking, outstring
            teamname = outstring[
                outstring.find(teamsearchstart)
                + len(teamsearchstart): outstring.find(teamsearchend)
            ]
            print ranking, teamname
            nodecounter += 1

            # Search for a tie within this ranking's segment of strsearch
            tiecounter = 0

            #   #25 perpetually has this problem. You can search for the str 'Dropped from rankings:' if 25th team
            if ranking == 25:
                outstring = outstring[: outstring.find("Dropped from rankings:")]
            teamsinstrsearch = outstring.count(teamsearchstart)
            # tiecounter = teamsinstrsearch - 1 # Not really the case becasue the strsearch has a gob ton of teams
            if teamsinstrsearch > 1:
                print "!!!!!!!!!", teamname, "is in a tie!!!! Total teams at", ranking, ":", teamsinstrsearch
                searchno3 = (
                    'class="number">' + str(ranking + 2) + "<"
                )  # you must put an exception jut in case there is greater than a 2 team tie; this only gets the ranking after 2 tied teams. If this was a 3 team tie, searching for x + 2 ranking would return None for the search
                findno3 = strsearch.find(searchno3)
                if findno3 == -1:
                    searchno3 = 'class="number">' + str(ranking + 3) + "<"
                    findno3 = strsearch.find(searchno3)
                    if findno3 == -1:
                        searchno3 = 'class="number">' + str(ranking + 4) + "<"
                        findno3 = strsearch.find(searchno3)
                tieoutstr = strsearch[findno1:findno3]
                # # print out the tieoutstr for tie troubleshooting. Comment out otherwise
                # print tieoutstr

                # Populate tieteamlist with all schools not initially set as teamname (like Texas A&M for final W '12).
                #   To do this, search thru tieoutstr string and find all instances of teamsearchstart.
                #   Append each that != teamname to tieteamlist

                # Method that may not resolve >2 ties but may be on to something
                # tieindicator = '''Table2__even" data-idx="'''+str(ranking)+'''"><td class='''
                # # 2019 edit 2 tieindicator  # Looks like Table2 --> Table and _td --> _TD
                tieindicator = (
                    '''Table__even" data-idx="''' + str(ranking) + """"><td class="""
                )
                tiesubstr_idx = tieoutstr.lower().find(tieindicator.lower())
                tiesubstr = tieoutstr[tiesubstr_idx : tiesubstr_idx + 3000]
                tieteamsubsearchstart = '''"><img alt="'''
                tieteamsubsearchend = '''" src="'''
                a_tie_team = tiesubstr[
                    tiesubstr.find(tieteamsubsearchstart)
                    + len(tieteamsubsearchstart) : tiesubstr.find(tieteamsubsearchend)
                ]
                print "Team tied at ranking", ranking, ":", a_tie_team

                # Append to tie team list
                # Check if a_tie_team is actually nothing
                #   This is the case for 2019 preseason #25: Stanford, ''
                if a_tie_team != '':
                    tieteamlist.append(a_tie_team)
                else:
                    pass  # For now. Check and see if the tieteamlist append for the other non-blank team is a problem.
                #           Reason for not initially not appending: 3-way tie where one is blank. Can't disregard other2
                #           Init 20 Oct 2019 test preseason 2019: this fix works.
                tieteamlist.append(teamname)
                print "Teams in the tie:", tieteamlist

        else:
            previousranking = ranking - 1

            searchno1new = searchno1.replace(str(ranking), str(previousranking))
            searchno2new = searchno1.replace(
                str(ranking + 1), str(ranking)
            )  # Set end of the search as current ranking
            # yeah but what if we didn't do that. There is no current ranking that finds that search no. kee searchno2 the same to bound the back end of the new outstring?
            searchno3 = (
                searchno2
            )  # responding to the comment above. This bounds the back end of the outstr; previousranking + 2 or ranking + 1

            # teamsearchstart = 'px" title="' # same
            # teamsearchend = '"/></a></span>' # same

            if searchno1new in strsearch:
                # This is where the change has to come from. Cannot search for the first instance of the findno1.
                findno1new = strsearch.find(searchno1new)
                findno3 = strsearch.find(searchno3)
                noinfinity = strsearch[
                    findno1new:findno3
                ]  # noinfinity == outstring in above func but has an ending
                # use the 2nd entity of each team search strs to find next team
                teamname = noinfinity[
                    findnth(noinfinity, teamsearchstart, 2)
                    + len(teamsearchstart) : findnth(noinfinity, teamsearchend, 2)
                ]
                print ranking, teamname
            else:
                print searchno1new, "<-- search term aint in large strsearch neither"  ##This is a test print statement
                teamname = "ERROR NO TEAM HERE"

        # ___
        if ranking in toptfive:
            print ranking, "ALREADY IN THE dictionary; missing", teamname
            # function to append other team to the dict
        else:
            if len(tieteamlist) != 0:  # If there is a tie:
                # dictrank = toptfive[ranking]
                toptfive[ranking] = []  # [teamname]
                for tieteam in tieteamlist:
                    toptfive[ranking].append(tieteam)
            else:  # If there is not a tie:
                # This is the option most often used on a normal basis.
                toptfive[ranking] = teamname
                # should be [teamname]? would have to refigure code downstream if so

    print "n =", nodecounter
    print toptfive
    for rank in toptfive:
        team = toptfive[rank]
        # print rank, team
        # Work out ties
        if type(team) is list:
            print rank, team
            teamstied = len(team)
            holderlist = [
                rank
            ]  # Go ahead and put the init rank in there. Add on others later.
            while len(holderlist) < teamstied:
                holderlist.append(len(holderlist) + rank)
            # print holderlist
            dividedrank = float(
                sum(holderlist) / float(teamstied)
            )  # Float to get that decimal point
            # One decimal point; you'll never have more than a .5, even for triple or quad ties.
            #   Odd ties = .5, even ties = int
            dividedrank_round = round(dividedrank, 1)
            # print dividedrank_round

            # Add the custom rank to the inverse rankings dict.
            for tieam in team:
                print dividedrank_round, tieam
                inverserankings[tieam] = dividedrank_round
        # Pass if a team is already in the inverse dict ie it has already been grabbed by the tie.
        elif team in inverserankings:
            # print team, "already in dict because of a tie. Will not be entered as", rank
            pass
        # Default if there is no tie
        else:
            print rank, team
            inverserankings[team] = rank
    print inverserankings
    print "______________________________________________________________________________"
    return inverserankings


# here, make sure others receiving votes gets documented. Use function to jump off of last point possible in
#   pollgrabber function to split to get top 25 in one function and other votes in another.
# Make sure in t25, you resolve ties.


def othersreceivingvotes(websitestrsearch, dictofthettfive):
    """ Takes the end of the ESPN AP Rankings detailing the other teams receiving votes and parses them
    to include them in a 25+ ranking list """
    # Starting holder variables
    tsixplus = {}
    nodecounter = 0
    rankingdict = {}
    inverserankingdict = {}

    # Determine at what number to start ORVs.
    #   Most times it's 26.
    #   However, if there is a tie at 25, that's multiple teams in that last spot, meaning that the start must be >= 27.
    # To start, Itterate through t25 inverse dict.
    #   If any value from that dict is > 25, you know you have to start after 26.
    #   Ie a val of 25.5 means others RV would start after 26, probably 27 in a two-way tie.
    # # dictofthettfive should = gettoptfive(websitestrsearch)
    overtfive = []
    defaultrank = 25
    for teem in dictofthettfive:
        raank = dictofthettfive[teem]
        # print teem, raank
        # 			* if score > 25, add team to list. len(list) + 25 = number you start at.
        if raank > 25:
            # print teem, raank
            overtfive.append(teem)
    teamstiedattfive = len(overtfive)
    if teamstiedattfive > 0:  # If there are any teams tied at 25:
        print "----", teamstiedattfive, "teams tied at #25:", overtfive
        tsixcounter = (
            defaultrank + teamstiedattfive
        )  # var name tsixcounter is a misnomer here b/c start # would >= 27
        # EX: 2 teams' scores are > 25. 2 teams append to holder_list. len(holder_list) = 2. 25+2 = 27. ORV stars @ 27.
        print "---- ORVs will start ranking at #", tsixcounter
    else:
        tsixcounter = defaultrank + 1  # ie 26

    # Get HTML of website from which to glean ORVs.
    strsearch = websitestrsearch
    # print strsearch

    apsearchterm = "AP Top 25"  # 'class="number">1'
    searchothersOG = 'class="title">Others receiving votes: </span> <!-- -->'
    searchothersnewbold = 'class="fw-bold">Others receiving votes: </span>'  # Test for new formatting of this str
    searchothers2019 = '''class="TableDetails__Headline">Others receiving votes: </span>'''

    # Test to see if new searchothers is the right way of searching now.
    searchothers = searchothers2019
    searchno2 = r"</p></div>\n</div>\n<div"  # </p></div>\n<div
    searchno2 = r"</p></div>\n<"  # /div'
    # searchno2 = r'</p></div>\n</div>\n</div>\n</div> <!-- // 50/50 Layout for Rankings'
    searchno2 = r'</p><p><span class="'#fw-bold">'
    teamsearchstart = '<span class="team-names">'
    teamsearchend = "</span><abbr title="
    weirdstr = "<!-- -->"

    # # TROUBLESHOOTING; Uncomment if there is an issue
    # # Testing which search term is not being found:
    # if apsearchterm.lower() in strsearch.lower():
    #     print apsearchterm, "is in this string; not the problem"
    # else:
    #     print apsearchterm, "is not in this string and is the problem"
    # if searchothers.lower() in strsearch.lower():
    #     print "var <strsearch> is in this string; not the problem"
    #     print "This is a common result of ESPN changing their HTML"
    #     print "Versions of the variable 'strsearch':"
    #     print "     Original:", searchothersOG
    #     print "    2018-1st half 2019:", searchothersnewbold
    #     print "    2019-present:", searchothers2019#tableheadline
    # else:
    #     print "var <strsearch> is not in this string and is the problem"

    if (
        apsearchterm.lower() in strsearch.lower()
        and searchothers.lower() in strsearch.lower()
    ):
        findap = strsearch.find(apsearchterm)
        findothers = strsearch.find(searchothers)
        findend = strsearch.find(searchno2)
        # print findothers
        outstring = strsearch[findothers + len(searchothers): findend]
        # print outstring
        # print "String length:", len(outstring)
        outstringlist = outstring.strip().split(",")
        # print outstringlist
        for othervote in outstringlist:
            if outstringlist[0] != othervote:
                othervote = othervote[1:]
            space = othervote.rfind(" ")
            pts = othervote[space + 1:]
            team = othervote[:space]
            if weirdstr in team:
                team = str(team.replace(weirdstr, ""))
            print team, pts
            intpts = int(pts)
            if intpts not in tsixplus:
                tsixplus[intpts] = [team]
            else:
                tsixplus[intpts].append(team)
        print tsixplus
        pointorder = sorted(tsixplus, reverse=True)

        print "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
        # Find average of ties
        for score in pointorder:
            teamlist = tsixplus[score]
            teamspervote = len(teamlist)
            if teamspervote == 1:
                rankingdict[tsixcounter] = teamlist[0]
                inverserankingdict[teamlist[0]] = tsixcounter
                tsixcounter += 1
            else:  # If there is a tie in votes:
                nextrank = tsixcounter
                lastrank = tsixcounter + teamspervote
                valstoaverage = range(nextrank, lastrank, 1)  # + 1, 1)
                designatedrank = numpy.mean(valstoaverage)
                for team in teamlist:
                    if team == teamlist[0]:
                        rankingdict[designatedrank] = [team]
                    else:
                        rankingdict[designatedrank].append(team)
                    inverserankingdict[team] = designatedrank
                tsixcounter += teamspervote
        print rankingdict
        print tsixcounter
        print inverserankingdict

        return inverserankingdict
    else:
        print "GRAVE ERROR"
        print "Check whether var <apsearchterm> and/or var <strsearch> in the search string and is the problem."
        print "Use problem solving code in the block b4 the previous if statement to do this"  # TROUBLESHOOTING header


def mergerankings(top25dict, othervotesdict):
    """ Merge the top 25 and beyond dictionaries into one dictionary by which we can assign points for XC scoring """
    rawmergeddict = {}

    for item in top25dict:
        rawmergeddict[item] = top25dict[item]
    for item in othervotesdict:
        rawmergeddict[item] = othervotesdict[item]

    print len(rawmergeddict), rawmergeddict

    return rawmergeddict


def orderedmergeddict(rawmergedic):
    """ _ """
    ordereddict = {}

    for team in rawmergedic:
        score = rawmergedic[team]
        if score not in ordereddict:
            ordereddict[score] = team
        else:
            ordereddict[score].append(team)

    print ordereddict
    return ordereddict


# # weekinquestion = apweeklyurlgenerator("Final", year=2012)  # Example of a top 25 tie that needs to be resolved.
# weekinquestion = apweeklyurlgenerator(10, year=2018)
#
# # pollgrabber(currentespnap)
# t25dict = gettoptfive(pollgrabber(weekinquestion))
# otherzdict = othersreceivingvotes(pollgrabber(weekinquestion))
#
# mergedict = mergerankings(t25dict, otherzdict)
# # scoreddict = orderedmergeddict(mergedict)
