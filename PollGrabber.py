import os, sys, requests, numpy
from bs4 import BeautifulSoup


tfcounter = 0
tfive = []
while tfcounter < 25:
    tfcounter += 1
    tfive.append(tfcounter)


def findnth(haystack, needle, n):
    """ <https://stackoverflow.com/questions/1883980/find-the-nth-occurrence-of-substring-in-a-string> """
    n = n - 1
    parts = haystack.split(needle, n + 1)
    if len(parts) <= n + 1:
        return -1
    return len(haystack) - len(parts[-1]) - len(needle)


def dateprocessing(year, week):
    """ Processes raw inputs of week and year for downstream use in multiple functions """
    prelist = ["preseason", "initial", "first", "init", "pre", str(0)]
    currentlist = ["current", "present", "default", None, str(None)]
    finallist = ["final", "f", "complete", "total", "last", "fin"]

    # YEAR FORMATTING
    year = str(year)
    # Format abbreviated dates for the 2000s
    if len(year) != 4:
        if len(year) == 2 and (year[0] == "1" or year[0] == "0"):
            # Assume the entry was an abreviation of a year. Add the 20__ before it.
            year = "20" + str(year)

    # WEEK FORMATTING
    # Preseason?
    week = str(week)
    if week.lower() in prelist:
        week = "1"

    # Current week?
    elif week.lower() in currentlist:
        week = "current"

    # Final?
    elif week.lower() in finallist:
        week = "final"
    # If the week entered is higher than 16, assume user wants final rankings.
    try:
        # 16 is the max # of regular season weeks allowed, tho usually 15. "CFB Leap Year." See 2014 & 2019
        if int(week) > 16:
            week = "final"
    except:
        pass

    if int(year) < int(2014):
        print(
            "Warning: Others Receiving Votes not stored by ESPN before the 2014 season."
        )

    # Compile into a list for returning
    #    Must return a list of strings
    datelist = [week, year]
    return year, week


def apweeklyurlgenerator(
    date_list
):  # date_list = result of dateprocessing() that's in list format (week, year)
    """ Generate a URL link for a specific week of AP Rankings. Preseason = week 1 """
    week = str(date_list[0])
    year = str(date_list[1])
    staticespn = (
        r"http://www.espn.com/college-football/rankings/_/week/6/year/2018/seasontype/2"
    )
    currentespnap = r"http://www.espn.com/college-football/rankings"
    # defaultlink = currentespnap
    oldurl1 = r"http://www.espn.com/college-football/rankings/_/week/"
    # Should be the default URL:
    aponlylinkespn2 = r"http://www.espn.com/college-football/rankings/_/poll/1/week/"
    defaultlink = aponlylinkespn2

    # finallist = ["final", "f", "complete", "total", "last"]
    #
    # currentlist = ["current", "present", "default"]

    # # Format the year correctly
    # year = str(year)
    # if len(year) != 4:
    #     if len(year) == 2 and (year[0] == "1" or year[0] == "0"):
    #         # Assume the entry was an abreviation of a year. Add the 20__ before it.
    #         year = "20" + str(year)
    #
    # # Week formatting
    # # Preseason?
    # week = str(week)
    # if week.lower() in prelist:
    #     week = "1"
    # # If the week entered is higher than 16, assume user wants final rankings.
    # try:
    #     if int(week) > 16:
    #         week = "final"
    # except:
    #     pass

    # Generate the URL
    # Is the week entered indicating the final week?
    if week.lower() == "final":  # in finallist:
        oldfinalurlexample = "http://www.espn.com/college-football/rankings/_/week/1/year/2017/seasontype/3"
        week1 = "1/year/"
        seasontype = "/seasontype/3"
        url = defaultlink + week1 + year + seasontype
    # Check for entries wanting the most up-to-date rankings
    elif week.lower() == "current":  # in currentlist:
        # just use the default link
        url = defaultlink  # default link
    # # Commented out b/c we want the user to get the results they want and not be confused by getting the current week
    # #     when they wanted another week. This will error out to let them know that.
    # elif week is None:
    #     # just use the default link by passing
    #     pass
    else:
        url2 = r"/year/"
        url3 = r"/seasontype/2"
        url = defaultlink + str(week) + url2 + year + url3
    print("Week", week, ",", year, "season")
    return url
    # Should be the default URL: r"http://www.espn.com/college-football/rankings/_/poll/1/"


def pollgrabber(aplink):
    """ Use BeautifulSoup to grab the AP Poll from ESPN's website,
    the link to which is generated by apweeklyurlgenerator() """
    print(aplink)
    r = requests.get(aplink)
    soup = BeautifulSoup(r.content, "html.parser")  # , 'html5lib')
    # trsearch = soup.find_all('title')
    trsearch = soup.find_all("div")  # 'table-caption')
    # print(trsearch)
    print("- - - - - - - -")
    nodecounter = 0
    ##########
    strsearch = str(trsearch)
    # print(strsearch)
    return strsearch


def gettoptfive(websitestrsearch):
    """ Parses the string-searched soup from bs4's html output of the AP Poll from ESPN generated by pollgrabber() """
    toptfive = {}
    nodecounter = 0
    inverserankings = {}

    strsearch = websitestrsearch
    # # print(this only to see the long version of the html returned by the search. Too much for PyCharm run window rn.)
    # print(strsearch)

    apsearchterm = "AP Top 25"  # 'class="number">1'
    for ranking in tfive:
        # print("Ranking in Top 25:", ranking  ## Test print(statement delete)
        # Commented out search strs no longer used but kept in case of future troubleshooting.
        # searchno1 = 'class="number">' + str(ranking) + '<'
        #  searchno1 = '<td class="tight-cell Table2__td">' + str(ranking) + "<"
        # # 2019 edit
        # searchno1 = '<td class="Table2__td">' + str(ranking) + "<"
        # # 2019 edit 2
        searchno1 = '<td class="Table__TD">' + str(ranking) + "<"

        # searchno2 = 'class="number">' + str(ranking + 1) + '<'
        #  searchno2 = '<td class="tight-cell Table2__td">' + str(ranking+1) + "<"
        # # 2019 edit
        # searchno2 = '<td class="Table2__td">' + str(ranking + 1) + "<"
        # # 2019 edit
        searchno2 = '<td class="Table__TD">' + str(ranking + 1) + "<"

        # teamsearchstart = '<span class="team-names">'
        teamsearchstart = 'px" title="'
        # teamsearchend = '</span><abbr title='
        teamsearchend = '"/></a></span>'

        tieteamlist = []
        if (
            apsearchterm.lower() in strsearch.lower()
            and searchno1.lower() in strsearch.lower()
        ):
            findap = strsearch.find(apsearchterm)
            findno1 = strsearch.lower().find(searchno1.lower())
            findno2 = strsearch.lower().find(searchno2.lower())
            outstring = strsearch[
                findno1:findno2
            ]  # +len(searchno2)]#]#Restore to the only ]
            # print(ranking, outstring)
            teamname = outstring[
                outstring.find(teamsearchstart)
                + len(teamsearchstart) : outstring.find(teamsearchend)
            ]
            print(ranking, teamname)
            nodecounter += 1

            # Search for a tie within this ranking's segment of strsearch
            tiecounter = 0

            #   #25 perpetually has this problem. You can search for the str 'Dropped from rankings:' if 25th team
            if ranking == 25:
                outstring = outstring[: outstring.find("Dropped from rankings:")]
            teamsinstrsearch = outstring.count(teamsearchstart)
            # tiecounter = teamsinstrsearch - 1 # Not really the case becasue the strsearch has a gob ton of teams
            if teamsinstrsearch > 1:
                print(
                    "!!!!!!!!!",
                    teamname,
                    "is in a tie!!!! Total teams at",
                    ranking,
                    ":",
                    teamsinstrsearch,
                )
                searchno3 = (
                    'class="number">' + str(ranking + 2) + "<"
                )  # you must put an exception jut in case there is greater than a 2 team tie; this only gets the ranking after 2 tied teams. If this was a 3 team tie, searching for x + 2 ranking would return None for the search
                findno3 = strsearch.find(searchno3)
                if findno3 == -1:
                    searchno3 = 'class="number">' + str(ranking + 3) + "<"
                    findno3 = strsearch.find(searchno3)
                    if findno3 == -1:
                        searchno3 = 'class="number">' + str(ranking + 4) + "<"
                        findno3 = strsearch.find(searchno3)
                tieoutstr = strsearch[findno1:findno3]
                # # print(out the tieoutstr for tie troubleshooting. Comment out otherwise)
                # print(tieoutstr)

                # Populate tieteamlist with all schools not initially set as teamname (like Texas A&M for final W '12).
                #   To do this, search thru tieoutstr string and find all instances of teamsearchstart.
                #   Append each that != teamname to tieteamlist

                # Method that may not resolve >2 ties but may be on to something
                # tieindicator = '''Table2__even" data-idx="'''+str(ranking)+'''"><td class='''
                # # 2019 edit 2 tieindicator  # Looks like Table2 --> Table and _td --> _TD
                tieindicator = (
                    '''Table__even" data-idx="''' + str(ranking) + """"><td class="""
                )
                tiesubstr_idx = tieoutstr.lower().find(tieindicator.lower())
                tiesubstr = tieoutstr[tiesubstr_idx : tiesubstr_idx + 3000]
                tieteamsubsearchstart = '''"><img alt="'''
                tieteamsubsearchend = '''" src="'''
                a_tie_team = tiesubstr[
                    tiesubstr.find(tieteamsubsearchstart)
                    + len(tieteamsubsearchstart) : tiesubstr.find(tieteamsubsearchend)
                ]
                print("Team tied at ranking", ranking, ":", a_tie_team)

                # Append to tie team list
                # Check if a_tie_team is actually nothing
                #   This is the case for 2019 preseason #25: Stanford, ''
                if a_tie_team != "":
                    tieteamlist.append(a_tie_team)
                else:
                    pass  # For now. Check and see if the tieteamlist append for the other non-blank team is a problem.
                #           Reason for not initially not appending: 3-way tie where one is blank. Can't disregard other2
                #           Init 20 Oct 2019 test preseason 2019: this fix works.
                tieteamlist.append(teamname)
                print("Teams in the tie:", tieteamlist)

        else:
            previousranking = ranking - 1

            searchno1new = searchno1.replace(str(ranking), str(previousranking))
            searchno2new = searchno1.replace(
                str(ranking + 1), str(ranking)
            )  # Set end of the search as current ranking
            # yeah but what if we didn't do that. There is no current ranking that finds that search no. kee searchno2 the same to bound the back end of the new outstring?
            searchno3 = (
                searchno2
            )  # responding to the comment above. This bounds the back end of the outstr; previousranking + 2 or ranking + 1

            # teamsearchstart = 'px" title="' # same
            # teamsearchend = '"/></a></span>' # same

            if searchno1new in strsearch:
                # This is where the change has to come from. Cannot search for the first instance of the findno1.
                findno1new = strsearch.find(searchno1new)
                findno3 = strsearch.find(searchno3)
                noinfinity = strsearch[
                    findno1new:findno3
                ]  # noinfinity == outstring in above func but has an ending
                # use the 2nd entity of each team search strs to find next team
                teamname = noinfinity[
                    findnth(noinfinity, teamsearchstart, 2)
                    + len(teamsearchstart) : findnth(noinfinity, teamsearchend, 2)
                ]
                print(ranking, teamname)
            else:
                print(
                    searchno1new, "<-- search term aint in large strsearch neither"
                )  ##This is a test print(statement
                teamname = "ERROR NO TEAM HERE"

        # ___
        if ranking in toptfive:
            print(ranking, "ALREADY IN THE dictionary; missing", teamname)
            # function to append other team to the dict
        else:
            if len(tieteamlist) != 0:  # If there is a tie:
                # dictrank = toptfive[ranking]
                toptfive[ranking] = []  # [teamname]
                for tieteam in tieteamlist:
                    toptfive[ranking].append(tieteam)
            else:  # If there is not a tie:
                # This is the option most often used on a normal basis.
                toptfive[ranking] = teamname
                # should be [teamname]? would have to refigure code downstream if so

    print("n =", nodecounter)
    print(toptfive)
    for rank in toptfive:
        team = toptfive[rank]
        # print(rank, team)
        # Work out ties
        if type(team) is list:
            print(rank, team)
            teamstied = len(team)
            holderlist = [
                rank
            ]  # Go ahead and put the init rank in there. Add on others later.
            while len(holderlist) < teamstied:
                holderlist.append(len(holderlist) + rank)
            # print(holderlist)
            dividedrank = float(
                sum(holderlist) / float(teamstied)
            )  # Float to get that decimal point
            # One decimal point; you'll never have more than a .5, even for triple or quad ties.
            #   Odd ties = .5, even ties = int
            dividedrank_round = round(dividedrank, 1)
            # print(dividedrank_round)

            # Add the custom rank to the inverse rankings dict.
            for tieam in team:
                print(dividedrank_round, tieam)
                inverserankings[tieam] = dividedrank_round
        # Pass if a team is already in the inverse dict ie it has already been grabbed by the tie.
        elif team in inverserankings:
            # print(team, "already in dict because of a tie. Will not be entered as", rank)
            pass
        # Default if there is no tie
        else:
            print(rank, team)
            inverserankings[team] = rank
    print(inverserankings)
    print(
        "______________________________________________________________________________"
    )
    return inverserankings


# here, make sure others receiving votes gets documented. Use function to jump off of last point possible in
#   pollgrabber function to split to get top 25 in one function and other votes in another.
# Make sure in t25, you resolve ties.


def othersreceivingvotes(websitestrsearch, dictofthettfive):
    """ Takes the end of the ESPN AP Rankings detailing the other teams receiving votes and parses them
    to include them in a 25+ ranking list """
    # Starting holder variables
    tsixplus = {}
    nodecounter = 0
    rankingdict = {}
    inverserankingdict = {}

    # Determine at what number to start ORVs.
    #   Most times it's 26.
    #   However, if there is a tie at 25, that's multiple teams in that last spot, meaning that the start must be >= 27.
    # To start, Itterate through t25 inverse dict.
    #   If any value from that dict is > 25, you know you have to start after 26.
    #   Ie a val of 25.5 means others RV would start after 26, probably 27 in a two-way tie.
    # # dictofthettfive should = gettoptfive(websitestrsearch)
    overtfive = []
    defaultrank = 25
    for teem in dictofthettfive:
        raank = dictofthettfive[teem]
        # print(teem, raank)
        # 			* if score > 25, add team to list. len(list) + 25 = number you start at.
        if raank > 25:
            # print(teem, raank)
            overtfive.append(teem)
    teamstiedattfive = len(overtfive)
    if teamstiedattfive > 0:  # If there are any teams tied at 25:
        print("----", teamstiedattfive, "teams tied at #25:", overtfive)
        tsixcounter = (
            defaultrank + teamstiedattfive
        )  # var name tsixcounter is a misnomer here b/c start # would >= 27
        # EX: 2 teams' scores are > 25. 2 teams append to holder_list. len(holder_list) = 2. 25+2 = 27. ORV stars @ 27.
        print("---- ORVs will start ranking at #", tsixcounter)
    else:
        tsixcounter = defaultrank + 1  # ie 26

    # Get HTML of website from which to glean ORVs.
    strsearch = websitestrsearch
    # print(strsearch)

    apsearchterm = "AP Top 25"  # 'class="number">1'
    searchothersOG = 'class="title">Others receiving votes: </span> <!-- -->'
    searchothersnewbold = (
        'class="fw-bold">Others receiving votes: </span>'
    )  # Test for new formatting of this str
    searchothers2019 = (
        """class="TableDetails__Headline">Others receiving votes: </span>"""
    )

    # Test to see if new searchothers is the right way of searching now.
    searchothers = searchothers2019
    searchno2 = r"</p></div>\n</div>\n<div"  # </p></div>\n<div
    searchno2 = r"</p></div>\n<"  # /div'
    # searchno2 = r'</p></div>\n</div>\n</div>\n</div> <!-- // 50/50 Layout for Rankings'
    searchno2 = r'</p><p><span class="'  # fw-bold">'
    teamsearchstart = '<span class="team-names">'
    teamsearchend = "</span><abbr title="
    weirdstr = "<!-- -->"

    # # TROUBLESHOOTING; Uncomment if there is an issue
    # # Testing which search term is not being found:
    # if apsearchterm.lower() in strsearch.lower():
    #     print(apsearchterm, "is in this string; not the problem")
    # else:
    #     print(apsearchterm, "is not in this string and is the problem")
    # if searchothers.lower() in strsearch.lower():
    #     print("var <strsearch> is in this string; not the problem")
    #     print("This is a common result of ESPN changing their HTML")
    #     print("Versions of the variable 'strsearch':")
    #     print("     Original:", searchothersOG)
    #     print("    2018-1st half 2019:", searchothersnewbold)
    #     print("    2019-present:", searchothers2019#tableheadline)
    # else:
    #     print("var <strsearch> is not in this string and is the problem")

    if (
        apsearchterm.lower() in strsearch.lower()
        and searchothers.lower() in strsearch.lower()
    ):
        findap = strsearch.find(apsearchterm)
        findothers = strsearch.find(searchothers)
        findend = strsearch.find(searchno2)
        # print(findothers)
        outstring = strsearch[findothers + len(searchothers) : findend]
        # print(outstring)
        # print("String length:", len(outstring))
        outstringlist = outstring.strip().split(",")
        # print(outstringlist)
        for othervote in outstringlist:
            if outstringlist[0] != othervote:
                othervote = othervote[1:]
            space = othervote.rfind(" ")
            pts = othervote[space + 1 :]
            team = othervote[:space]
            if weirdstr in team:
                team = str(team.replace(weirdstr, ""))
            print(team, pts)
            intpts = int(pts)
            if intpts not in tsixplus:
                tsixplus[intpts] = [team]
            else:
                tsixplus[intpts].append(team)
        print(tsixplus)
        pointorder = sorted(tsixplus, reverse=True)

        print(
            "- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
        )
        # Find average of ties
        for score in pointorder:
            teamlist = tsixplus[score]
            teamspervote = len(teamlist)
            if teamspervote == 1:
                rankingdict[tsixcounter] = teamlist[0]
                inverserankingdict[teamlist[0]] = tsixcounter
                tsixcounter += 1
            else:  # If there is a tie in votes:
                nextrank = tsixcounter
                lastrank = tsixcounter + teamspervote
                valstoaverage = range(nextrank, lastrank, 1)  # + 1, 1)
                designatedrank = numpy.mean(valstoaverage)
                for team in teamlist:
                    if team == teamlist[0]:
                        rankingdict[designatedrank] = [team]
                    else:
                        rankingdict[designatedrank].append(team)
                    inverserankingdict[team] = designatedrank
                tsixcounter += teamspervote
        print(rankingdict)
        print(tsixcounter)
        print(inverserankingdict)

        return inverserankingdict
    else:
        print("GRAVE ERROR")
        print(
            "Check whether var <apsearchterm> and/or var <strsearch> in the search string and is the problem."
        )
        print(
            "Use problem solving code in the block b4 the previous if statement to do this"
        )  # TROUBLESHOOTING header


def mergerankings(top25dict, othervotesdict):
    """ Merge the top 25 and beyond dictionaries into one dictionary by which we can assign points for XC scoring """
    rawmergeddict = {}

    for item in top25dict:
        rawmergeddict[item] = top25dict[item]
    for item in othervotesdict:
        rawmergeddict[item] = othervotesdict[item]

    print(len(rawmergeddict), rawmergeddict)

    return rawmergeddict


def orderedmergeddict(rawmergedic):
    """ _ """
    ordereddict = {}

    for team in rawmergedic:
        score = rawmergedic[team]
        if score not in ordereddict:
            ordereddict[score] = team
        else:
            ordereddict[score].append(team)

    print(ordereddict)
    return ordereddict


# # weekinquestion = apweeklyurlgenerator("Final", year=2012)  # Example of a top 25 tie that needs to be resolved.
# weekinquestion = apweeklyurlgenerator(10, year=2018)
#
# # pollgrabber(currentespnap)
# t25dict = gettoptfive(pollgrabber(weekinquestion))
# otherzdict = othersreceivingvotes(pollgrabber(weekinquestion))
#
# mergedict = mergerankings(t25dict, otherzdict)
# # scoreddict = orderedmergeddict(mergedict)
